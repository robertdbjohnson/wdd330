<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W04Reading</title>
</head>
<body>
    <pre>
        The legacy DOM had a useful property called document.forms that returns an HTML collection of all the forms in the 
        document in the order they appear in the markup. Even though there is only one form in our example, a collection 
        will still be returned, so we have to use index notation to return the first (and only) form object, like so:
            const form = document.forms[0];

        Hidden Input Fields...I thought this was really interesting and new to me.
            Hidden fields can be created using input fields with type='hidden' . These are not displayed by the browser, but
            have a 'value' attribute that can contain information that is submitted with the form. They are often used to 
            send information such as settings or information that the user has already provided. Note that the information 
            in these fields is in no way secret, as it’s visible in the HTML, so shouldn’t be used for sensitive data. The 
            value of a hidden input field can be changed using JavaScript in the same was as any other input field.
        
        Here's a few important definitions...
        Encapsulation
            When I use my juicer, I put the fruit into the machine, press the 'on' button and out comes the juice. I haven’t a
            clue how it does it—only that it makes a very loud noise! This demonstrates the concept of encapsulation: the inner
            workings are kept hidden inside the object and only the essential functionalities are exposed to the end user, such 
            as the 'on' button. In OOP, this involves keeping all the programming logic inside an object and making methods 
            available to implement the functionality, without the outside world needing to knowhowit’s done.

        Polymorphism
            My juicer isn't the only appliance I own that has an 'on' button, although the way the on button works is slightly 
            different for each appliance. My juicer also uses the same electrical outlet as other appliances in my kitchen. 
            I can also place various types of fruit into it and it still juices them. These examples demonstrate the concept 
            of polymorphism: the same process can be used for different objects. In OOP, this means various objects can share 
            the same method, but also have the ability to override shared methods with a more specific implementation.
        
        Inheritance
            I’d really like the next model up from my juicer, as it can deal with more types of fruit and it’s a bit quieter.
            Even though it has these extra features, I’m sure that inside it uses many of the same parts that my juicer has. 
            This demonstrates the concept of inheritance: taking the features of one object then adding some new features. 
            In OOP, this means we can take an object that already exists and inherit all its properties and methods. 
            We can then improve on its functionality by adding new properties and methods.
            
        Classes
            Many object-oriented languages, such as Java and Ruby, are known asclass-basedlanguages. This is because they use 
            a class to define a blueprint for an object. Objects are then created as an instance of that class, and inherit all 
            the properties and methods of the class. In my juicer example, the juicer class would represent the design of the 
            juicer, and each juicer that’s made on the production line would be instances of that class.
            
            JavaScript didn't have classes before ES6, and used the concept of using actual objects as the blueprint for 
            creating more objects. This is known as aprototype-basedlanguage. In the juicer example, this might involve 
            building an actual prototype juicer then using this prototype as the basis for making all the other juicers. The 
            juicers based on the prototype would be able to do everything the prototype could do, with some being able to do 
            even more. Even though ES6 now supports classes, it still uses this prototypal inheritance model in the background.

        Getter and Setters
            An object property descriptor can have get() and set() methods instead of a value attribute. All objects must have one or the other, they can't have both. The get() and set() methods can be used to control how a property is set using assignment and the value that is returned when a property is queried.
            They are particularly useful if a property relies on the value of another property.

            me.age = 21;
            me.retirementAge = 65;
            Object.defineProperty(me, 'yearsToRetirement',{
                get() {
                    if(this.age > this.retirementAge) { return 0; }
                    else { return this.retirementAge - this.age; }
                },
                set(value) {
                    this.age = this.retirementAge - value;
                    return value;
                }
            });

        
    </pre>
</body>
</html>